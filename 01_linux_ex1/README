< your secret here >


Kernel System Calls
-------------------
In general, the program whatIdo designed to create welcomeToDevOpsMay22 directory with 7-0-0 permisions for the owner of the file and no other permissions
in that folder ASCII file with no line terminators under the name: goodluck
is created with 7-5-5 permissions
that contains text line: There you go... tell me what I do...
Running strace on the file shows that:
The file designed to be run with sudo permissions otherwise exits with 1, permission denied.





Broken Symlink
-------------------
Solution for Uber's broken code due to moving file to a different path from the one that is used in code:
    ln backups/backup.obj backup.obj
Create new linked file with the same name and path that is used in the Uber's code to a linked moved file

Binary Numbers
--------------
1. Convert the following binary numbers to a decimals:
    a. 111 = 7 --> 00000111 => 0*2^7+0*2^6+0*2^5+0*2^4+0*2^3+1*2^2+2^1*1+2^0*1
    b. 100 = 4 --> 00000100 => 0*2^7+0*2^6+0*2^5+0*2^4+0*2^3+2^2*1+2^1*0+2^0*0
    c. 10110 = 22 --> 00010110 ==> 0*2^7+0*2^6+0*2^5+1*2^4+0*2^3+1*2^2+1*2^1+0*2^0
2. What is the available decimal range represented by a 8 bits binary number?
    a. 256 numbers (0...255)
3. Given a 9 bits binary number, suggest a method to represent a negative numbers between 0-255
    a. (1/0)[1 for negative, 0 for positive] 11111111 for exmple: 111111111 would be -255 or 1101 would be -5.
4. Suggest a method to represent a floating point numbers (e.g. 12.3,  15.67, 0.231) using a 8 bits binary numbers:
    a. bit[7]bit[6]bit[5]bit[4]bit[3]bit[2]bit[1]bit[0].bit[7]bit[6]bit[5]bit[4]bit[3]bit[2]bit[1]bit[0] ... bit[7]bit[6]bit[5]bit[4]bit[3]bit[2]bit[1]bit[0]
        Example for the calculation of not integer base10 to base2:
        12.3
        12 in base2 = 1100
        0.3 in base2
        0.3*2=0.6 --> taking 0 and moving .6 to next bit calculation until we receive .0
        0.6*2=1.2 --> taking 1 and moving .2 to next bit calculation until we receive .0
        0.2*2=0.4 --> taking 0 and moving .4 to next bit calculation until we receive .0
        0.4*2=0.8 --> taking 0 and moving .8 to next bit calculation until we receive .0
        0.8*2=1.6 --> taking 1 and moving .6 to next bit calculation until we receive .0
        0.6*2=1.2 --> taking 1 and moving .2 to next bit calculation until we receive .0
        0.2*2=0.4 --> taking 0 and moving .4 to next bit calculation until we receive .0
        0.4*2=0.8 --> taking 0 and moving .8 to next bit calculation until we receive .0
        -----01001100------
        0.8*2=1.6 --> taking 1 and moving .6 to next bit calculation until we receive .0
        0.6*2=1.2 --> taking 1 and moving .2 to next bit calculation until we receive .0
        0.2*2=0.4 --> taking 0 and moving .4 to next bit calculation until we receive .0
        0.4*2=0.8 --> taking 0 and moving .8 to next bit calculation until we receive .0
        0.8*2=1.6 --> taking 1 and moving .6 to next bit calculation until we receive .0
        0.6*2=1.2 --> taking 1 and moving .2 to next bit calculation until we receive .0
        0.2*2=0.4 --> taking 0 and moving .4 to next bit calculation until we receive .0
        0.4*2=0.8 --> taking 0 and moving .8 to next bit calculation until we receive .0
        ----- The 12.3 in base2 starts to look like 00001100.01001100
        and so on until: 00001100.01001100 11001100 11001100 11001100 11001100 11001100 11001100 11001101
        with the same method
        15.67 = 00001111.10101011 10000101 00011110 10111000 01010001 11101011 10000101 00011110 00000001
        0.231 = 0000000.00111011 00100010 11010000 11100101 01100000 01000001 10001001 00110111 00000001
